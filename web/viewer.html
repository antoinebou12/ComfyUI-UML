<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kroki diagram viewer</title>
  <style>
    /* ComfyUI default theme–aligned palette (Settings → Appearance); matches node/canvas colors.
       These are standalone defaults; edit the values below to match a specific ComfyUI theme. */
    :root {
      --comfy-bg-canvas: #222;
      --comfy-bg-node: #353535;
      --comfy-border: #666;
      --comfy-text: #AAA;
      --comfy-text-secondary: #999;
      --comfy-text-highlight: #FFF;
      --comfy-button-bg: #333;
      --comfy-button-hover: #444;
      --comfy-message: #888;
      --comfy-error: #e66;
      --comfy-link: #6af;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--comfy-bg-canvas);
      color: var(--comfy-text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--comfy-bg-node);
      border-bottom: 1px solid var(--comfy-border);
      flex-wrap: wrap;
    }
    .toolbar button {
      padding: 6px 12px;
      border: 1px solid var(--comfy-border);
      border-radius: 4px;
      background: var(--comfy-button-bg);
      color: var(--comfy-text);
      cursor: pointer;
      font-size: 13px;
    }
    .toolbar button:hover { background: var(--comfy-button-hover); border-color: var(--comfy-border); }
    .toolbar button:disabled { opacity: 0.5; cursor: not-allowed; }
    .toolbar .zoom-label {
      margin-left: 4px;
      font-size: 12px;
      color: var(--comfy-text-secondary);
    }
    .toolbar .toolbar-sep {
      width: 1px;
      height: 20px;
      background: var(--comfy-border);
      margin: 0 4px;
    }
    .container {
      flex: 1;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: var(--comfy-bg-canvas);
      position: relative;
    }
    .pan-zoom-layer {
      transform-origin: 0 0;
      cursor: grab;
      display: inline-block;
    }
    .container.has-diagram {
      cursor: grab;
    }
    .container.panning {
      cursor: grabbing;
    }
    .container.crop-mode {
      cursor: crosshair;
    }
    .viewport {
      overflow: visible;
      border: 1px solid var(--comfy-border);
      border-radius: 4px;
      background: var(--comfy-bg-node);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2);
      display: block;
    }
    .viewport img { display: block; max-width: none; max-height: none; }
    .viewport svg { display: block; }
    .message {
      padding: 28px 24px;
      text-align: center;
      color: var(--comfy-message);
      font-size: 14px;
      line-height: 1.5;
    }
    .message.error { color: var(--comfy-error); }
    .message a { color: var(--comfy-link); }
    .message code { color: var(--comfy-text-secondary); font-size: 13px; }
    .save-status { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); padding: 8px 16px; border-radius: 4px; font-size: 13px; z-index: 10; display: none; }
    .save-status.success { background: var(--comfy-border); color: var(--comfy-text); }
    .save-status.error { background: var(--comfy-error); color: #fff; }
    .toolbar button.active { background: var(--comfy-button-hover); border-color: var(--comfy-link); }
    .crop-overlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed var(--comfy-link);
      background: rgba(106, 175, 255, 0.08);
      box-sizing: border-box;
      display: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button type="button" id="zoom-out" title="Zoom out">−</button>
    <button type="button" id="zoom-fit" title="Fit to view">Fit</button>
    <button type="button" id="zoom-100" title="100%">100%</button>
    <button type="button" id="zoom-in" title="Zoom in">+</button>
    <span class="zoom-label" id="zoom-label">100%</span>
    <span class="toolbar-sep" aria-hidden="true"></span>
    <button type="button" id="download" title="Save diagram to your computer" disabled>Save locally</button>
    <button type="button" id="save-comfy" title="Save to ComfyUI output/uml/ (only when opened from ComfyUI)" disabled>Save to ComfyUI</button>
    <button type="button" id="copy-link" title="Copy Kroki URL" disabled>Copy link</button>
    <span class="toolbar-sep" aria-hidden="true"></span>
    <button type="button" id="crop-btn" title="Select region to crop" disabled>Crop</button>
    <button type="button" id="clear-selection" title="Clear selection" style="display: none;">Clear selection</button>
    <button type="button" id="save-crop-local" title="Save cropped region to your computer" style="display: none;">Save crop locally</button>
    <button type="button" id="save-crop-comfy" title="Save cropped region to ComfyUI output/uml/" style="display: none;">Save crop to ComfyUI</button>
    <button type="button" id="zoom-to-selection" title="Zoom to fit selection" style="display: none;">Zoom to selection</button>
    <button type="button" id="copy-image" title="Copy diagram (or selection) as image" disabled>Copy image</button>
  </div>
  <div class="container">
    <div id="content">
      <div class="message" id="message">Paste the <b>kroki_url</b> from the UML node output into the address bar as <code>?url=<i>kroki_url</i></code>, or add it above to view a diagram.</div>
    </div>
    <div class="crop-overlay" id="crop-overlay"></div>
  </div>
  <div class="save-status" id="save-status" aria-live="polite"></div>

  <script>
    (function () {
      const content = document.getElementById("content");
      const message = document.getElementById("message");
      const zoomOutBtn = document.getElementById("zoom-out");
      const zoomFitBtn = document.getElementById("zoom-fit");
      const zoom100Btn = document.getElementById("zoom-100");
      const zoomInBtn = document.getElementById("zoom-in");
      const zoomLabel = document.getElementById("zoom-label");
      const downloadBtn = document.getElementById("download");
      const saveComfyBtn = document.getElementById("save-comfy");
      const copyLinkBtn = document.getElementById("copy-link");
      const saveStatus = document.getElementById("save-status");
      const cropBtn = document.getElementById("crop-btn");
      const clearSelectionBtn = document.getElementById("clear-selection");
      const saveCropLocalBtn = document.getElementById("save-crop-local");
      const saveCropComfyBtn = document.getElementById("save-crop-comfy");
      const zoomToSelectionBtn = document.getElementById("zoom-to-selection");
      const copyImageBtn = document.getElementById("copy-image");
      const cropOverlay = document.getElementById("crop-overlay");

      let krokiUrl = "";
      let currentBlob = null;
      let currentFormat = "svg";
      let scale = 1;
      let panX = 0;
      let panY = 0;
      const minScale = 0.25;
      const maxScale = 4;
      const step = 0.25;

      let isPanning = false;
      let startClientX = 0;
      let startClientY = 0;
      let startPanX = 0;
      let startPanY = 0;

      let isCropMode = false;
      let selectionRect = null;
      let isSelecting = false;
      let selectStartX = 0;
      let selectStartY = 0;
      let selectEndX = 0;
      let selectEndY = 0;

      function getPanZoomLayer() {
        return content.querySelector(".pan-zoom-layer");
      }

      function getViewportElement() {
        const layer = getPanZoomLayer();
        return layer ? layer.querySelector(".viewport") : null;
      }

      function getContentBounds() {
        const viewport = getViewportElement();
        if (!viewport) return null;
        const svg = viewport.querySelector("svg");
        const img = viewport.querySelector("img");
        if (svg) {
          const vb = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width !== undefined
            ? svg.viewBox.baseVal
            : svg.getBBox();
          return { left: vb.x, top: vb.y, width: vb.width, height: vb.height };
        }
        if (img && img.naturalWidth) {
          return { left: 0, top: 0, width: img.naturalWidth, height: img.naturalHeight };
        }
        return null;
      }

      function clientToContent(clientX, clientY) {
        const viewport = getViewportElement();
        const bounds = getContentBounds();
        if (!viewport || !bounds) return null;
        const r = viewport.getBoundingClientRect();
        const x = bounds.left + (clientX - r.left) / r.width * bounds.width;
        const y = bounds.top + (clientY - r.top) / r.height * bounds.height;
        return { x: x, y: y };
      }

      function contentToClient(contentX, contentY) {
        const viewport = getViewportElement();
        const bounds = getContentBounds();
        if (!viewport || !bounds) return null;
        const r = viewport.getBoundingClientRect();
        const x = r.left + (contentX - bounds.left) / bounds.width * r.width;
        const y = r.top + (contentY - bounds.top) / bounds.height * r.height;
        return { x: x, y: y };
      }

      function applyTransform() {
        const layer = getPanZoomLayer();
        if (layer) {
          layer.style.transform = "translate(" + panX + "px, " + panY + "px) scale(" + scale + ")";
        }
        zoomLabel.textContent = Math.round(scale * 100) + "%";
      }

      function updateCropOverlay() {
        if (!selectionRect || !cropOverlay) return;
        const container = document.querySelector(".container");
        if (!container) return;
        const cr = container.getBoundingClientRect();
        const p1 = contentToClient(selectionRect.x, selectionRect.y);
        const p2 = contentToClient(selectionRect.x + selectionRect.w, selectionRect.y + selectionRect.h);
        if (!p1 || !p2) return;
        const left = Math.min(p1.x, p2.x) - cr.left;
        const top = Math.min(p1.y, p2.y) - cr.top;
        const w = Math.abs(p2.x - p1.x);
        const h = Math.abs(p2.y - p1.y);
        cropOverlay.style.left = left + "px";
        cropOverlay.style.top = top + "px";
        cropOverlay.style.width = w + "px";
        cropOverlay.style.height = h + "px";
        cropOverlay.style.display = w > 1 && h > 1 ? "block" : "none";
      }

      function updateCropUI() {
        const hasSelection = selectionRect && selectionRect.w > 0 && selectionRect.h > 0;
        cropBtn.classList.toggle("active", isCropMode);
        clearSelectionBtn.style.display = hasSelection ? "" : "none";
        saveCropLocalBtn.style.display = hasSelection ? "" : "none";
        saveCropComfyBtn.style.display = hasSelection ? "" : "none";
        zoomToSelectionBtn.style.display = hasSelection ? "" : "none";
        if (hasSelection) updateCropOverlay();
        else cropOverlay.style.display = "none";
        const container = document.querySelector(".container");
        if (container) container.classList.toggle("crop-mode", isCropMode);
      }

      function setupPanZoom() {
        const container = document.querySelector(".container");
        if (!container) return;

        container.addEventListener("wheel", function (e) {
          const layer = getPanZoomLayer();
          if (!layer) return;
          e.preventDefault();
          const layerRect = layer.getBoundingClientRect();
          const scaleFactor = 1 - e.deltaY * 0.002;
          const scaleNew = Math.max(minScale, Math.min(maxScale, scale * scaleFactor));
          if (scaleNew === scale) return;
          const cx = e.clientX - layerRect.left;
          const cy = e.clientY - layerRect.top;
          panX = cx - (cx - panX) * (scaleNew / scale);
          panY = cy - (cy - panY) * (scaleNew / scale);
          scale = scaleNew;
          applyTransform();
        }, { passive: false });

        container.addEventListener("pointerdown", function (e) {
          const layer = getPanZoomLayer();
          if (!layer || e.button !== 0) return;
          if (isCropMode) {
            const pt = clientToContent(e.clientX, e.clientY);
            if (pt) {
              isSelecting = true;
              selectStartX = pt.x;
              selectStartY = pt.y;
              selectEndX = pt.x;
              selectEndY = pt.y;
              selectionRect = { x: pt.x, y: pt.y, w: 0, h: 0 };
              updateCropOverlay();
              e.currentTarget.setPointerCapture(e.pointerId);
            }
            return;
          }
          isPanning = true;
          startClientX = e.clientX;
          startClientY = e.clientY;
          startPanX = panX;
          startPanY = panY;
          container.classList.add("panning");
          e.currentTarget.setPointerCapture(e.pointerId);
        });

        container.addEventListener("pointermove", function (e) {
          if (isSelecting) {
            const pt = clientToContent(e.clientX, e.clientY);
            if (pt) {
              selectEndX = pt.x;
              selectEndY = pt.y;
              const x = Math.min(selectStartX, selectEndX);
              const y = Math.min(selectStartY, selectEndY);
              selectionRect = {
                x: x,
                y: y,
                w: Math.abs(selectEndX - selectStartX),
                h: Math.abs(selectEndY - selectStartY)
              };
              updateCropOverlay();
            }
            e.preventDefault();
            return;
          }
          if (!isPanning) return;
          panX = startPanX + (e.clientX - startClientX);
          panY = startPanY + (e.clientY - startClientY);
          applyTransform();
          e.preventDefault();
        });

        container.addEventListener("pointerup", function (e) {
          if (e.button !== 0) return;
          if (isSelecting) {
            isSelecting = false;
            e.currentTarget.releasePointerCapture(e.pointerId);
            if (selectionRect && selectionRect.w < 2 && selectionRect.h < 2) selectionRect = null;
            updateCropUI();
            return;
          }
          isPanning = false;
          container.classList.remove("panning");
          e.currentTarget.releasePointerCapture(e.pointerId);
        });

        container.addEventListener("pointercancel", function () {
          isSelecting = false;
          isPanning = false;
          container.classList.remove("panning");
          updateCropUI();
        });
      }

      setupPanZoom();

      function getUrlParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      }

      function showMessage(text, isError) {
        message.textContent = text;
        message.className = "message" + (isError ? " error" : "");
        message.style.display = "block";
        document.querySelector(".container")?.classList.remove("has-diagram");
      }

      function hideMessage() {
        message.style.display = "none";
      }

      function setZoom(s) {
        scale = Math.max(minScale, Math.min(maxScale, s));
        panX = 0;
        panY = 0;
        applyTransform();
      }

      function fitToView() {
        const container = document.querySelector(".container");
        const layer = getPanZoomLayer();
        if (!layer || !container) return;
        const viewport = layer.querySelector(".viewport");
        const el = viewport ? viewport.querySelector("img, svg") : null;
        if (!el) return;
        const cr = container.getBoundingClientRect();
        const w = el.offsetWidth || el.getBoundingClientRect().width;
        const h = el.offsetHeight || el.getBoundingClientRect().height;
        if (w <= 0 || h <= 0) return;
        const sx = (cr.width - 40) / w;
        const sy = (cr.height - 40) / h;
        scale = Math.min(sx, sy, 1);
        panX = 0;
        panY = 0;
        applyTransform();
      }

      function showSaveStatus(text, isError) {
        saveStatus.textContent = text;
        saveStatus.className = "save-status " + (isError ? "error" : "success");
        saveStatus.style.display = "block";
        clearTimeout(saveStatus._hide);
        saveStatus._hide = setTimeout(function () { saveStatus.style.display = "none"; }, 4000);
      }

      function saveBlobToComfyUI(blob, filename, buttonEl, successMessage) {
        if (!blob) return;
        buttonEl.disabled = true;
        const formData = new FormData();
        formData.append("file", blob, filename);
        fetch("/comfyui-uml/save", { method: "POST", body: formData })
          .then(function (res) { return res.json().then(function (data) { return { ok: res.ok, data: data }; }); })
          .then(function (result) {
            buttonEl.disabled = false;
            if (result.ok) {
              showSaveStatus(successMessage + (result.data.filename || ""), false);
            } else {
              showSaveStatus(result.data.error || "Save failed", true);
            }
          })
          .catch(function (err) {
            buttonEl.disabled = false;
            showSaveStatus(err.message || "Save to ComfyUI only works when the viewer is opened from ComfyUI", true);
          });
      }

      zoomOutBtn.addEventListener("click", function () { setZoom(scale - step); });
      zoomInBtn.addEventListener("click", function () { setZoom(scale + step); });
      zoom100Btn.addEventListener("click", function () { setZoom(1); });
      zoomFitBtn.addEventListener("click", fitToView);

      downloadBtn.addEventListener("click", function () {
        if (!currentBlob) return;
        const a = document.createElement("a");
        a.href = URL.createObjectURL(currentBlob);
        a.download = "diagram." + currentFormat;
        a.click();
        URL.revokeObjectURL(a.href);
      });

      saveComfyBtn.addEventListener("click", function () {
        if (!currentBlob) return;
        saveBlobToComfyUI(
          currentBlob,
          "diagram_" + Date.now() + "." + currentFormat,
          saveComfyBtn,
          "Saved to output/uml/"
        );
      });

      copyLinkBtn.addEventListener("click", function () {
        if (!krokiUrl) return;
        navigator.clipboard.writeText(krokiUrl).then(function () {
          const t = copyLinkBtn.textContent;
          copyLinkBtn.textContent = "Copied!";
          setTimeout(function () { copyLinkBtn.textContent = t; }, 1500);
        });
      });

      cropBtn.addEventListener("click", function () {
        if (!getPanZoomLayer()) return;
        isCropMode = !isCropMode;
        if (!isCropMode) {
          selectionRect = null;
        }
        updateCropUI();
      });

      clearSelectionBtn.addEventListener("click", function () {
        selectionRect = null;
        isCropMode = false;
        updateCropUI();
      });

      function getPngBlobForClipboard(cb) {
        const viewport = getViewportElement();
        if (!viewport) { cb(null); return; }
        const svg = viewport.querySelector("svg");
        const img = viewport.querySelector("img");
        function drawToCanvas(w, h, draw) {
          const c = document.createElement("canvas");
          c.width = Math.max(1, Math.floor(w));
          c.height = Math.max(1, Math.floor(h));
          const ctx = c.getContext("2d");
          if (!ctx) { cb(null); return; }
          draw(ctx, c);
          c.toBlob(function (blob) { cb(blob || null); }, "image/png");
        }
        if (selectionRect && selectionRect.w > 0 && selectionRect.h > 0) {
          if (img && img.complete && img.naturalWidth) {
            drawToCanvas(selectionRect.w, selectionRect.h, function (ctx, c) {
              ctx.drawImage(img, selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h, 0, 0, c.width, c.height);
            });
            return;
          }
          if (svg) {
            const clone = svg.cloneNode(true);
            const r = selectionRect;
            clone.setAttribute("viewBox", r.x + " " + r.y + " " + r.w + " " + r.h);
            clone.setAttribute("width", String(r.w));
            clone.setAttribute("height", String(r.h));
            const s = new XMLSerializer().serializeToString(clone);
            const url = URL.createObjectURL(new Blob([s], { type: "image/svg+xml" }));
            const im = new Image();
            im.onload = function () {
              drawToCanvas(r.w, r.h, function (ctx, c) {
                ctx.drawImage(im, 0, 0, c.width, c.height);
              });
              URL.revokeObjectURL(url);
            };
            im.onerror = function () { URL.revokeObjectURL(url); cb(null); };
            im.src = url;
            return;
          }
        }
        if (img && img.complete) {
          const w = img.naturalWidth || img.offsetWidth;
          const h = img.naturalHeight || img.offsetHeight;
          if (currentBlob && currentBlob.type === "image/png") {
            cb(currentBlob);
            return;
          }
          drawToCanvas(w, h, function (ctx, c) {
            ctx.drawImage(img, 0, 0, c.width, c.height);
          });
          return;
        }
        if (svg) {
          const w = svg.viewBox && svg.viewBox.baseVal.width ? svg.viewBox.baseVal.width : svg.getBBox().width;
          const h = svg.viewBox && svg.viewBox.baseVal.height ? svg.viewBox.baseVal.height : svg.getBBox().height;
          const s = new XMLSerializer().serializeToString(svg);
          const url = URL.createObjectURL(new Blob([s], { type: "image/svg+xml" }));
          const im = new Image();
          im.onload = function () {
            drawToCanvas(w, h, function (ctx, c) {
              ctx.drawImage(im, 0, 0, c.width, c.height);
            });
            URL.revokeObjectURL(url);
          };
          im.onerror = function () { URL.revokeObjectURL(url); cb(null); };
          im.src = url;
          return;
        }
        cb(null);
      }

      copyImageBtn.addEventListener("click", function () {
        if (!getPanZoomLayer()) return;
        getPngBlobForClipboard(function (blob) {
          if (!blob) {
            showSaveStatus("Copy not supported or failed", true);
            return;
          }
          if (!navigator.clipboard || !navigator.clipboard.write) {
            showSaveStatus("Copy not supported in this browser", true);
            return;
          }
          navigator.clipboard.write([new ClipboardItem({ "image/png": blob })])
            .then(function () {
              showSaveStatus("Copied to clipboard", false);
            })
            .catch(function () {
              showSaveStatus("Paste from the downloaded image if copy failed", true);
            });
        });
      });

      zoomToSelectionBtn.addEventListener("click", function () {
        if (!selectionRect || !selectionRect.w || !selectionRect.h) return;
        const container = document.querySelector(".container");
        const layer = getPanZoomLayer();
        if (!container || !layer) return;
        const cr = container.getBoundingClientRect();
        const padding = 40;
        const sx = (cr.width - padding) / selectionRect.w;
        const sy = (cr.height - padding) / selectionRect.h;
        scale = Math.min(sx, sy, maxScale);
        scale = Math.max(minScale, scale);
        const centerX = selectionRect.x + selectionRect.w / 2;
        const centerY = selectionRect.y + selectionRect.h / 2;
        applyTransform();
        const contentRect = content.getBoundingClientRect();
        const containerCenterX = cr.left + cr.width / 2;
        const containerCenterY = cr.top + cr.height / 2;
        panX = containerCenterX - contentRect.left - (layer.offsetLeft || 0) - centerX * scale;
        panY = containerCenterY - contentRect.top - (layer.offsetTop || 0) - centerY * scale;
        applyTransform();
        updateCropOverlay();
      });

      function getCroppedBlob(cb) {
        if (!selectionRect || selectionRect.w <= 0 || selectionRect.h <= 0) { cb(null); return; }
        const viewport = getViewportElement();
        if (!viewport) { cb(null); return; }
        const svg = viewport.querySelector("svg");
        const img = viewport.querySelector("img");
        if (svg) {
          const clone = svg.cloneNode(true);
          const r = selectionRect;
          clone.setAttribute("viewBox", r.x + " " + r.y + " " + r.w + " " + r.h);
          clone.setAttribute("width", String(r.w));
          clone.setAttribute("height", String(r.h));
          const s = new XMLSerializer().serializeToString(clone);
          cb(new Blob([s], { type: "image/svg+xml" }), "svg");
          return;
        }
        if (img && img.complete && img.naturalWidth) {
          const c = document.createElement("canvas");
          c.width = Math.max(1, Math.floor(selectionRect.w));
          c.height = Math.max(1, Math.floor(selectionRect.h));
          const ctx = c.getContext("2d");
          if (!ctx) { cb(null); return; }
          ctx.drawImage(img, selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h, 0, 0, c.width, c.height);
          c.toBlob(function (blob) { cb(blob || null, "png"); }, "image/png");
          return;
        }
        cb(null);
      }

      saveCropLocalBtn.addEventListener("click", function () {
        getCroppedBlob(function (blob, format) {
          if (!blob) return;
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "diagram_crop_" + Date.now() + "." + (format || "png");
          a.click();
          URL.revokeObjectURL(a.href);
          showSaveStatus("Cropped region saved locally", false);
        });
      });

      saveCropComfyBtn.addEventListener("click", function () {
        getCroppedBlob(function (blob, format) {
          if (!blob) return;
          saveBlobToComfyUI(
            blob,
            "uml_crop_" + Date.now() + "." + (format || "png"),
            saveCropComfyBtn,
            "Saved crop to output/uml/"
          );
        });
      });

      function renderSvg(svgText) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, "image/svg+xml");
        const svg = doc.documentElement;
        if (svg && svg.tagName && svg.tagName.toLowerCase() === "svg") {
          const viewport = document.createElement("div");
          viewport.className = "viewport";
          viewport.appendChild(svg);
          const layer = document.createElement("div");
          layer.className = "pan-zoom-layer";
          layer.appendChild(viewport);
          content.innerHTML = "";
          content.appendChild(layer);
          document.querySelector(".container")?.classList.add("has-diagram");
          scale = 1;
          panX = 0;
          panY = 0;
          applyTransform();
          downloadBtn.disabled = false;
          saveComfyBtn.disabled = false;
          copyLinkBtn.disabled = false;
          cropBtn.disabled = false;
          copyImageBtn.disabled = false;
        } else {
          showMessage("Invalid SVG received.", true);
        }
      }

      function renderPng(blob) {
        const img = document.createElement("img");
        img.alt = "Diagram";
        const viewport = document.createElement("div");
        viewport.className = "viewport";
        viewport.appendChild(img);
        const layer = document.createElement("div");
        layer.className = "pan-zoom-layer";
        layer.appendChild(viewport);
        content.innerHTML = "";
        content.appendChild(layer);
        document.querySelector(".container")?.classList.add("has-diagram");
        img.onload = function () {
          scale = 1;
          panX = 0;
          panY = 0;
          applyTransform();
        };
        img.src = URL.createObjectURL(blob);
        downloadBtn.disabled = false;
        saveComfyBtn.disabled = false;
        copyLinkBtn.disabled = false;
        cropBtn.disabled = false;
        copyImageBtn.disabled = false;
      }

      function loadDiagram(url) {
        krokiUrl = url;
        currentBlob = null;
        selectionRect = null;
        isCropMode = false;
        downloadBtn.disabled = true;
        saveComfyBtn.disabled = true;
        copyLinkBtn.disabled = true;
        cropBtn.disabled = true;
        copyImageBtn.disabled = true;
        updateCropUI();

        if (url.startsWith("data:")) {
          const comma = url.indexOf(",");
          if (comma === -1) {
            showMessage("Invalid data URL.", true);
            return;
          }
          const header = url.slice(0, comma).toLowerCase();
          const payload = url.slice(comma + 1);
          if (header.includes("image/svg+xml")) {
            currentFormat = "svg";
            let svgText = "";
            if (header.includes("base64")) {
              try {
                svgText = atob(payload.replace(/-/g, "+").replace(/_/g, "/"));
              } catch (e) {
                showMessage("Invalid base64 in data URL.", true);
                return;
              }
            } else {
              try {
                svgText = decodeURIComponent(payload);
              } catch (e) {
                svgText = payload;
              }
            }
            hideMessage();
            renderSvg(svgText);
            currentBlob = new Blob([svgText], { type: "image/svg+xml" });
            krokiUrl = "";
            copyLinkBtn.disabled = true;
          } else {
            showMessage("Data URL must be image/svg+xml.", true);
          }
          return;
        }

        currentFormat = url.indexOf("/svg/") !== -1 ? "svg" : "png";
        showMessage("Loading…", false);

        fetch(url)
          .then(function (res) {
            if (!res.ok) throw new Error("HTTP " + res.status);
            return currentFormat === "svg" ? res.text() : res.blob();
          })
          .then(function (data) {
            hideMessage();
            if (currentFormat === "svg") {
              renderSvg(data);
              currentBlob = new Blob([data], { type: "image/svg+xml" });
            } else {
              currentBlob = data;
              renderPng(data);
            }
          })
          .catch(function (err) {
            showMessage("Failed to load diagram: " + err.message + ". If the Kroki URL is from another origin, try opening it in a new tab.", true);
          });
      }

      const url = getUrlParam("url");
      if (url) {
        try {
          const decoded = decodeURIComponent(url);
          loadDiagram(decoded);
        } catch (e) {
          loadDiagram(url);
        }
      }
    })();
  </script>
</body>
</html>
